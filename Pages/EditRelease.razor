@page "/editrelease/{releaseDirectory}"

@using TED.Enums;
@using TED.Extensions;
@using TED.Models.MetaData;
@using TED.Processors;
@using System.Text.RegularExpressions
@using System.ComponentModel.DataAnnotations
@inject NavigationManager NavigationManager
@inject ILoggerFactory LoggerFactory

<PageTitle>Editing Release</PageTitle>

<MudToolBar DisableGutters=true>
    <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Delete" Color="Color.Error" Size="Size.Medium" OnClick="@( async (e) => await DeleteRelease())">Delete</MudButton>
    <MudButton Class="ml-3" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Remove" Color="Color.Warning" Size="Size.Medium" OnClick="@( async (e) => await DeleteReleaseImages())">Delete Release Images</MudButton>
    <MudMenu Class="ml-3" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Menu" EndIcon="@Icons.Material.Filled.KeyboardArrowDown" Color="Color.Info" Size="Size.Medium" Label="Modify Actions">
        <MudMenuItem Class="ml-3" Icon="@Icons.Material.Filled.Person" OnClick="@( async (e) => await PromoteTrackArtist())">Promote Track Artist</MudMenuItem>
        <MudMenuItem Class="ml-3" Icon="@Icons.Material.Filled.Numbers" OnClick="@( async (e) => await RenumberTracks())">Renumber Tracks</MudMenuItem>
        <MudMenuItem Class="ml-3" Icon="@Icons.Material.Filled.Numbers" OnClick="@( async (e) => await RemoveArtistFromTrackArtists())">Remove Artist From Track Artists</MudMenuItem>
        <MudMenuItem Class="ml-3" Icon="@Icons.Material.Filled.Numbers" OnClick="@( async (e) => await ReplaceTracksArtistSeperators())">Replace Track Artist Seperators</MudMenuItem>
        <MudMenuItem Class="ml-3" Icon="@Icons.Material.Filled.CalendarMonth" OnClick="@( async (e) => await SetYearToCurrent())">Set Year To Current</MudMenuItem>
    </MudMenu>
    <MudMenu Class="ml-3" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.EditNote" EndIcon="@Icons.Material.Filled.KeyboardArrowDown" Color="Color.Info" Size="Size.Medium" Label="Trim Track Titles">
        <MudMenuItem OnClick="@( async (e) => await TrimTrackTitles(1))">1</MudMenuItem>
        <MudMenuItem OnClick="@( async (e) => await TrimTrackTitles(2))">2</MudMenuItem>
        <MudMenuItem OnClick="@( async (e) => await TrimTrackTitles(3))">3</MudMenuItem>
        <MudMenuItem OnClick="@( async (e) => await TrimTrackTitles(4))">4</MudMenuItem>
        <MudMenuItem OnClick="@( async (e) => await TrimTrackTitles(5))">5</MudMenuItem>
    </MudMenu>
</MudToolBar>

<div Class="d-flex flex-wrap">
    <MudText Class="mt-4">Editing Directory: @ReleaseDirectory</MudText>
    <MudSpacer />
    <MudBadge Dot="true" Color="@( _release.Status == Enums.Statuses.Ok || _release.Status == Enums.Statuses.Reviewed ? Color.Success : Color.Error )" Class="mx-6 my-4">
        <MudText>Release Status</MudText>
    </MudBadge>
</div>


@using FluentValidation
@using TED.Utility;

<MudGrid>
    <MudItem xs="8">
        <MudCard>
            <MudForm Model="@_release" @ref="@form" Validation="@(releaseValidator.ValidateValue)" ValidationDelay="0">
                <MudCardContent>
                    <MudSelect @bind-Value="_release.Status" T="Enums.Statuses" Label="Status" AnchorOrigin="Origin.BottomCenter">
                        @foreach (var e in Enum.GetValues(typeof(Enums.Statuses)).Cast<Enums.Statuses>())
                        {
                            <MudSelectItem Value="@(e)" />
                        }
                    </MudSelect>
                    <MudTextField @bind-Value="_release.Artist.Text"
                                  For="@(() => _release.Artist.Text)"
                                  Immediate="true"
                                  Label="Artist Name" />
                    <MudTextField @bind-Value="_release.ReleaseData.Text"
                                  For="@(() => _release.ReleaseData.Text)"
                                  Immediate="true"
                                  Label="Release Title" />
                    <MudDatePicker @bind-Date="_release.ReleaseDateDateTime"
                                   For="@(() => _release.ReleaseDateDateTime)"
                                   Label="Release Date"
                                   DateFormat="yyyy-MM-dd" />
                    <MudSimpleTable Style="pa-4 overflow-x: auto;0" Hover="true" Striped="true">
                    <colgroup>
                       <col span="1" style="width: 5%;">
                       <col span="1" style="width: 5%;">
                       <col span="1" style="width: 35%;">
                       <col span="1" style="width: 55%;">
                    </colgroup>
                    <thead>
                        <tr>
                            <th>Media Number</th>
                            <th>Track Number</th>
                            <th>Track Artist Name</th>
                            <th>Title</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var media in _release.Media.OrderBy(x => x.MediaNumber))
                        {
                            @foreach (var track in media.Tracks.OrderBy(x => x.TrackNumber))
                            {
                                    <tr Class="@($"track-{(track.IsValid ? "valid" : "invalid")}")">
                                    <td>
                                            <MudNumericField T="short?" @bind-Value="@media.MediaNumber"
                                                  For="@(() => @media.MediaNumber)"
                                                  Min="1"
                                                  Max="500"
                                                  Immediate="true" />

                                    </td>
                                    <td>
                                            <MudNumericField @bind-Value="@track.TrackNumber"
                                                  For="@(() => @track.TrackNumber)"
                                                     Min="1"
                                                     Max="1000"
                                                  Immediate="true"/>
                                    </td>
                                        <td>
                                            <MudTextField T="string" @bind-Value="@track.TrackArtist.ArtistData.Text"
                                                  For="@(() => @track.TrackArtist.ArtistData.Text)"
                                                  Immediate="true" />
                                        </td>
                                    <td>
                                            <MudTextField @bind-Value="@track.Title"
                                                  For="@(() => @track.Title)"
                                                      Immediate="true"/>
                                    </td>
                                </tr>
                            }
                        }
                    </tbody>
                </MudSimpleTable>
                </MudCardContent>
            </MudForm>
            <MudCardActions>
                <MudButton Disabled="@_submitted" Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto" OnClick="@(async () => await Submit())">Save</MudButton>
            </MudCardActions>
        </MudCard>
    </MudItem>
    <MudItem xs="4">
        <MudSimpleTable Style="pa-4 overflow-x: auto;">
            <thead>
                <tr>
                    @foreach (var h in messageHeadings)
                    {
                        <th>@h</th>
                    }
                </tr>
            </thead>
            <tbody>
                @foreach (var message in _release.ProcessingMessages.OrderBy(x => x.IsOK).ThenBy(x => x.Message))
                {
                    <tr style="@($"message-ok-{ ( message.IsOK ? "1" : "0" )}")">
                        <td>@message.StatusIndicator</td>
                        <td>@message.Message</td>
                    </tr>
                }
            </tbody>
        </MudSimpleTable>
    </MudItem>
</MudGrid>

@code {
    [Inject]
    ISnackbar Snackbar { get; set; }
    bool success;
    string[] errors = { };
    MudForm form;
    ReleaseFluentValidator releaseValidator = new ReleaseFluentValidator();
    string[] messageHeadings = { "Type", "Details" };
    bool _submitted = false;

    Release _release = new Release
        {
            Artist = new Models.DataToken(),
            ReleaseData = new Models.DataToken(),
            Media = new List<ReleaseMedia>
            {
                new ReleaseMedia 
                { 
                    Tracks = new List<Track>
                    {
                        new Track
                        {
                            TrackArtist = new Artist()
                            {
                                ArtistData = new Models.DataToken()
                            }
                        }
                    }
                }
            }
        };

    //    OrderDetailsModelFluentValidator orderDetailsValidator = new OrderDetailsModelFluentValidator();

    private async Task DeleteRelease()
    {
        Directory.Delete(_release.Directory, true);
        Snackbar.Add("Deleted!");
        NavigationManager.NavigateTo("/staging");
    }

    private async Task DeleteReleaseImages()
    {
        _release.CoverImage = null;
        var releaseImagesInDirectory = ImageHelper.FindImageTypeInDirectory(new DirectoryInfo(_release.Directory), ImageType.Release, SearchOption.TopDirectoryOnly);
        if (releaseImagesInDirectory?.Any() ?? false)
        {
            Parallel.ForEach(releaseImagesInDirectory, releaseImageInDirectory =>
            {
                releaseImageInDirectory.Delete();
            });
        }
        var secondaryReleaseImagesInDirectory = ImageHelper.FindImageTypeInDirectory(new DirectoryInfo(_release.Directory), ImageType.ReleaseSecondary, SearchOption.TopDirectoryOnly);
        if (secondaryReleaseImagesInDirectory?.Any() ?? false)
        {
            Parallel.ForEach(secondaryReleaseImagesInDirectory, secondaryReleaseImageInDirectory =>
            {
                secondaryReleaseImageInDirectory.Delete();
            });
        }
    }

    private async Task RemoveArtistFromTrackArtists()
    {
        foreach (var media in _release.Media)
        {
            foreach (var track in media.Tracks.Where(x => x.TrackArtist?.ArtistData != null))
            {
                track.TrackArtist.ArtistData.Text = RemoveArtistFromTrackArtist(_release.Artist?.Text, track.TrackArtist.ArtistData.Text);
            }
        }
    }

    private async Task ReplaceTracksArtistSeperators()
    {
        foreach (var media in _release.Media)
        {
            foreach (var track in media.Tracks.Where(x => x.TrackArtist?.ArtistData != null))
            {
                track.TrackArtist.ArtistData.Text = ReplaceTrackArtistSeperators(track.TrackArtist.ArtistData.Text);
            }
        }
    }

    public static string ReplaceTrackArtistSeperators(string? trackArtist)
    {
        if (trackArtist.Nullify() == null)
        {
            return null;
        }
        return Regex.Replace(trackArtist, $"\\s*(&|ft(\\.)*|feat)\\s*|\\s+x\\s+|\\s*\\,\\s*",  "/", RegexOptions.IgnoreCase).Trim();
    }

    public static string? RemoveArtistFromTrackArtist(string? artist, string? trackArtist)
    {
        if(artist.Nullify() == null)
        {
            return trackArtist;
        }
        if(trackArtist.Nullify() == null)
        {
            return null;
        }
        return Regex.Replace(trackArtist, $"\\s*({artist})\\s*(&|and|with)*", string.Empty).Trim();
    }

    private async Task RenumberTracks()
    {
        var looper = 1;
        foreach(var media in _release.Media)
        {
            looper = 1;
            foreach (var track in media.Tracks)
            {
                track.TrackNumber = looper;
                looper++;
            }            
        }
        _release.TrackCount = looper;
    }

    private async Task TrimTrackTitles(int stringLengthToTrim)
    {
        foreach (var media in _release.Media)
        {
            foreach (var track in media.Tracks.Where(x => x.Title.Nullify() != null))
            {
                track.Title = track.Title.Substring(stringLengthToTrim, track.Title.Length - stringLengthToTrim);
            }
        }
    }

    private async Task PromoteTrackArtist()
    {
        _release.Artist = _release.Media.First().Tracks.First().TrackArtist.ArtistData;
        foreach (var media in _release.Media)
        {
            foreach (var track in media.Tracks)
            {
                track.TrackArtist = new Artist()
                {
                    ArtistData = new Models.DataToken()
                };
            }
        }
    }

    private async Task SetYearToCurrent()
    {
        _release.ReleaseDateDateTime = DateTime.UtcNow;
    }

    private async Task Submit()
    {
        await form.Validate();

        if (form.IsValid)
        {
            _submitted = true;
            var saveProcessor = new ReleaseSaveProcessor(LoggerFactory.CreateLogger<ReleaseSaveProcessor>());
            var result = await saveProcessor.ProcessAsync(DateTime.UtcNow, _release);
            if(!result.Item1)
            {
                errors = result.Item2.ToArray();
                Snackbar.Add("Error saving", MudBlazor.Severity.Error);
                _submitted = false;
            }
            else
            {
                Snackbar.Add("Saved!");
                NavigationManager.NavigateTo("/staging");
            }
        }
    }

    /// <summary>
    /// A standard AbstractValidator which contains multiple rules and can be shared with the back end API
    /// </summary>
    /// <typeparam name="Release"></typeparam>
    public class ReleaseFluentValidator : AbstractValidator<Release>
    {
        public ReleaseFluentValidator()
        {
            RuleFor(x => x.ReleaseData.Text)
                .NotEmpty()
                .Length(1, 250);

            RuleFor(x => x.Artist.Text)
                .NotEmpty()
                .Length(1, 250);

            RuleFor(x => x.ReleaseDateDateTime)
                .NotEmpty()
                .ExclusiveBetween(DateTime.MinValue, DateTime.MaxValue);

            RuleForEach(x => x.Media)
                .SetValidator(new MediaFluentValidator());
        }

        public class MediaFluentValidator : AbstractValidator<ReleaseMedia>
        {
            public MediaFluentValidator()
            {
                RuleFor(x => x.MediaNumber)
                    .NotNull()
                    .ExclusiveBetween((short)(1), (short)1000);
                RuleForEach(x => x.Tracks)
                    .SetValidator(new TrackFluentValidator());
            }

        }

        public class TrackFluentValidator : AbstractValidator<Track>
        {
            public TrackFluentValidator()
            {
                RuleFor(x => x.TrackNumber)
                    .ExclusiveBetween(1, 1000);
                RuleFor(x => x.TrackArtist.ArtistData.Text)
                    .MaximumLength(500);
                RuleFor(x => x.Title)
                    .NotEmpty()
                    .MaximumLength(250);
            }

        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
         {
             var result = await ValidateAsync(ValidationContext<Release>.CreateWithOptions((Release)model, x => x.IncludeProperties(propertyName)));
             if (result.IsValid)
             {
                 return Array.Empty<string>();
             }
             return result.Errors.Select(e => e.ErrorMessage);
         };
    }

    [Parameter]
    public string? ReleaseDirectory { get; set; }

    protected override async Task OnInitializedAsync()
    {
        ReleaseDirectory = System.Net.WebUtility.UrlDecode(ReleaseDirectory);
        DirectoryProcessor directoryProcessor = new DirectoryProcessor(LoggerFactory.CreateLogger<DirectoryProcessor>());
        _release = await directoryProcessor.ProcessAsync(DateTime.UtcNow, ReleaseDirectory, Directory.GetFiles(ReleaseDirectory ?? string.Empty)) ?? _release;
        _release.ReleaseDateDateTime = DateTime.Parse(_release.ReleaseDate ?? DateTime.MinValue.ToString());
    }

}